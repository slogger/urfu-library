#### Билеты

1. [Модель фон Неймана и прерывания.](https://github.com/slogger/UrFU-task/blob/master/1%20%D1%81%D0%B5%D0%BC%D0%B5%D1%81%D1%82%D1%80/%D0%9E%D0%A1/%D0%AD%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD/os_ticket.md#%D0%91%D0%B8%D0%BB%D0%B5%D1%82-1-%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-%D1%84%D0%BE%D0%BD-%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
2. [Понятие и структура операционной системы.](https://github.com/slogger/UrFU-task/blob/master/1%20%D1%81%D0%B5%D0%BC%D0%B5%D1%81%D1%82%D1%80/%D0%9E%D0%A1/%D0%AD%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD/os_ticket.md#%D0%91%D0%B8%D0%BB%D0%B5%D1%82-2-%D0%9F%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D0%B5-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B9-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B)
3. Назначение, состав и функции ОС.
4. [Классификация и примеры современных ОС.]()
5. Понятие и назначение ядра ОС.
6. Структура ядра современных ОС.
7. Управление виртуальной памятью.
8. Стратегии подкачек и вытеснения страниц памяти.
9. [Программы, процессы и потоки.]()
10. [Кооперативная и вытесняющая многозадачность.]()
11. Планировщики задач с приоритетами.
12. Основные примитивы синхронизации потоков.
13. Проблема тупиков (deadlocks) и способы борьбы с ней.
14. [Гармонически взаимодействующие процессы.]()
15. Механизмы межзадачного взаимодействия.
16. Классификация внешних устройств.
17. Драйверы внешних устройств.
18. Файлы, каталоги и файловые системы.
19. Основные структуры файловых систем.
20. Идентификация пользователей и права доступа.
21. [Виды атак на операционные системы.]()
22. Иерархия классов безопасных систем.
23. [Многоуровневые системы безопасности.]()
24. Проблема тайных ходов в операционной системе.

#### Ответы
##### Билет 1: Модель фон Неймана и прерывания.

![](https://raw.github.com/slogger/UrFU-task/master/1%20%D1%81%D0%B5%D0%BC%D0%B5%D1%81%D1%82%D1%80/%D0%9E%D0%A1/%D0%AD%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD/src/img-2.png)

Шины:

1. управлений
2. адреса
3. данных

Принципы Фон Неймана

+ Неизменность архитектуры

1. Принцип двоичного кодирования
2. Принцип однородности памяти
  * Программа и данные в одном памяти *(пристонская архитектура)*
  * В разной памяти *(нарвардская архитектура)*
  
  Команда (код операции) + данные

  Команды и данные хранятся в одной и той же памяти и внешне в памяти неразличимы. Распознать их можно только по способу использования; то есть одно и то же значение в ячейке памяти может использоваться и как данные, и как команда, и как адрес в зависимости лишь от способа обращения к нему. Это позволяет производить над командами те же операции, что и над числами.
3. Принцип адресуемости памяти

    Структурно основная память состоит из пронумерованных ячеек, причем процессору в произвольный момент доступна любая ячейка. Двоичные коды команд и данных разделяются на единицы информации, называемые словами, и хранятся в ячейках памяти, а для доступа к ним используются номера соответствующих ячеек — адреса.
4. Принцип программного управления

    В ЦП есть регистр **IP**

    Все вычисления, предусмотренные алгоритмом решения задачи, должны быть представлены в виде программы, состоящей из последовательности управляющих слов — команд. Каждая команда предписывает некоторую операцию из набора операций, реализуемых вычислительной машиной. Команды программы хранятся в последовательных ячейках памяти вычислительной машины и выполняются в естественной последовательности, то есть в порядке их положения в программе.
5. Прерывания

    **Особый случай в работе процессора**

    Прерывание может вызвать сам процессор (например, если он не может распознать команду), тогда процессор передаст управление по адресу, где находится обработчик прерывания. Всегда должна быть возможность вернуться из прерывания. Чтобы вернуться к выполнению программы, надо хранить много информации.
    
    Есть 3 типа прерываний:
    
    1. Внутреннее прерывание – вызывает сам процессор *(деление на 0)*
    2. Внешнее прерывание – вызывается устройствами ввода-вывода. Обрабатывает прерывания контроллер прерываний.
    3. Программное прерывание – прерывание, вызывающееся программистом.
      
    

##### Билет 2: Понятие и структура операционной системы.
ОС -

1. Комплекс программ обеспечивающих взаимодействие пользователя и компьютера
2. Расширенная машина
 
    ![](https://raw.github.com/slogger/UrFU-task/master/1%20%D1%81%D0%B5%D0%BC%D0%B5%D1%81%D1%82%D1%80/%D0%9E%D0%A1/%D0%AD%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD/src/img-1.png)
3. Менеджер ресурсов
  * Во времени *(принтер)*
  * В пространстве *(пямять, диск)*

Архитектура компьютера

1. Жестко заданная *(калькулятор)*
2. С набором команд

##### Билет 4: Классификация и примеры современных ОС.
1. Неполноценные ОС. 

  Выполняют часть функций: обеспечивают работу устройств, предоставляют пользовательский интерфейс, управляют файловой системой, запускают 1 программу. *(DOS)*
2. 	Операционные системы общего назначения.

  1. Системы пакетной обработки
  2. ОС с разделением времени 
  
  Система разделяет время процессора между пользователями. Системы становятся псевдопараллельными.
3. ОС рельного времмнни. 

  Система для управления оборудованием. Отличие: гарантированное время отклика на внешнее воздействие. Есть одна оперативная задача (критичная по времени отклика) и фоновые задачи.

##### Билет 9: Программы, процессы и потоки.
Программа и процесс – это не одно и то же. Программа – это то, что хранится в дисковом файле, процесс – это то, что создается, когда мы запускаем программу.
Первый шаг при создании процесса – выделение памяти под процесс. Каждый процесс имеет свое адресное пространство.

Процесс – это просто адресное пространство, в котором работает программа.
Поток – thread (нить).
После выделения процесса запускается главный поток – исполняющая часть программы. Поток существует во времени, а не в пространстве.

В Windows есть два типа потоков:

*	UI-threads – пользовательский интерфейс
*	Working threads – рабочие потоки

Новый процесс всегда создается другим процессом. Первый процесс всегда запускается вместе с ОС. В UNIX порождающая функция fork – порождает копию родительского процесса, в котором потом меняются код и данные. В Windows – CreateProcess, создается сразу нужный процесс. fork позволяет иметь общую часть кода у экземпляров одной программы. В Windows если запустить 100 раз word, то будет 100 его копий в памяти. В Windows нет иерархии процессов, все процессы самостоятельные. В UNIX есть чёткая иерархия процессов.
Права процесса = права порожд. процесса пересечь с правами текущего пользователя.
Ни в UNIX, ни в Windows завершение процесса не приводит к завершению дочерних процессов, но завершение процесса приводит к уничтожению всех его потоков. Демоны и сервисы – потоки, которые выполняются и без родительского процесса.
Завершение процесса – это завершение всех его потоков.

1.	Нормальное завершение потока – все сделал
2.	Нормальное завершение по ошибке (из-за невозможности дальше выполняться)
3.	Фатальная ошибка, не предусмотренная программистом
4.	Насильное завершение потока ОС

##### Билет 10: Кооперативная и вытесняющая многозадачность.
* Вытесняющая – ОС делит время между задачами, гарантируя, что достанется каждой.
* Кооперативная – сама программа решает, когда дать другим поработать *(реализована в Win3.x)*.

##### Билет 14: Гармонически взаимодействующие процессы.
Везде под процессом понимается нечто исполняемое; сейчас это уместнее называть потоком.

2 процесса называются гармонично взаимодейстующими, если они независимы друг от друга, имеют общие данные, но ресурсов общих у них нет, а весь обмен данными происходит в определенных точках. 

В Windows программы не могут иметь общих данных.

Трубы (pipes) работают между двумя процессами. Бывают безымянные (всегда односторонние) и именованные. Одна программа создает трубу и кидает туда данные. Другая программа в нужное время заходит в трубу, берет данные, а если их там нет, то ждет.

Mailbox(Unix)/Mailslot(Windows) – механизм почтовых ящиков. Нужен, если есть редко используемый сервис. Ему можно кидать данные в ящик, а он будет время от времени его проверять. Почтовых ящиков может быть много.


##### Билет 21: Виды атак на операционные системы.
Основные угрозы (приёмы нарушения безопасности) можно поделить на внешние и внутренние. Внешние – вирусы, черви и DoS-атаки.

* DoS-атака – попытка уронить машину, чтобы она перестала реагировать на внешние воздействия. Является сильным средством общественного влияния.
* Троян – обычная с виду программа, которая ничего не портит, но незаметно сливает информацию и посылает её кому-нибудь. Её цель – не быть замеченной.
* Логические бомбы – программы, проверяющие наличие некоторого условия, и при наличии совершающие некоторые действия. Особый вид логических бомб – чёрные ходы (отладочная информация, случайно или специально не убранная из программы).
* Фальшивые экраны логинов – при запуске системы заменяют экран логина своей программой, выглядящей так же, чтобы узнать логины-пароли всех пользователей.

##### Билет 23: Многоуровневые системы безопасности.
Многоуровневая безопасность состоит в наличии разных уровней секретности, при этом на каждом уровне происходит сужение круга лиц. У каждого пользователя есть ранг, чем он выше, тем прав больше. Есть 2 модели:

1.	N может читать все у рангов <= N, а писать рангам >= N.
   Здесь нарушается целостность прав.
2.	N может читать все у рангов >= N, а писать рангам <= N.
   Здесь есть целостность, но нет безопасности.

Безопасность систем проранжирована в книге Orange Book. Безопасность ранжируется так: D, C1, C2, B1, B2, A1. Там же описано, что характеризует каждый уровень безопасности.

Система уровня A1 – безопасность системы можно доказать формально. Пока таких нет.

B1 и B2 – военные, правительственные системы.

Большинство систем находятся в C1 и C2. 

Даже C2 достаточно сложно получить. 

Из сколь угодно надёжной системы можно воровать информацию, поскольку все тайные ходы не перекрыть. Так что система A1 должна обезопасить хотя бы от внешней угрозы.

Сливание информации может осуществляться методом стеганографии – передачи информации поверх другой, защищённой.
 
